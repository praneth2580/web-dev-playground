<!doctype html>
<html lang="en" data-theme="light">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quote Writer | Instagram Quote Maker</title>
    <meta name="description"
        content="Create beautiful, shareable quote images for Instagram and social media. Customize fonts, backgrounds, and styling with this free browser-based tool.">
    <meta name="keywords"
        content="quote maker, instagram quotes, image editor, text on image, social media graphics, quote generator">
    <link rel="canonical" href="https://praneth2580.github.io/web-dev-playground/quote-writer/">
    <link rel="icon" type="image/x-icon" href="./favicon.png">
    
    <!-- CSS -->
    <link rel="stylesheet" href="style.css">
    
    <!-- Scripts -->
    <script src="./bundle.js"></script>
</head>

<body>
    <div class="app-container">
        <!-- Header -->
        <header class="app-header">
            <div class="title-group">
                <h1>Quote Writer</h1>
                <p>Create aesthetic Instagram posts in seconds.</p>
            </div>
            
            <button id="theme-toggle" class="theme-toggle-btn" aria-label="Toggle Dark Mode">
                <!-- Sun Icon -->
                <svg id="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                <!-- Moon Icon (hidden by default logic but we can toggle visibility via CSS or JS) -->
                <svg id="moon-icon" class="hidden" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
            </button>
        </header>

        <!-- Controls Section -->
        <section id="controls" class="card">
            
            <!-- Quote Input -->
            <label for="quote">Your Quote</label>
            <textarea id="quote" placeholder="Write something inspiring...">Believe you can and you're halfway there.</textarea>
            
            <button id="randomBtn" class="btn btn-primary" style="width: 100%; margin-top: 0.75rem; margin-bottom: 1.5rem;">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>
                Randomize Quote
            </button>

            <!-- Author Input -->
            <label for="author">Author (optional)</label>
            <input id="author" type="text" placeholder="Unknown" value="Theodore Roosevelt" />

            <!-- Typography & Sizing -->
            <div class="grid-2" style="margin-top: 1.5rem;">
                <div>
                    <label for="font">Font Family</label>
                    <select id="font">
                        <option value="48px 'Georgia', serif">Serif — Georgia</option>
                        <option value="46px 'Helvetica Neue', Arial, sans-serif">Sans — Helvetica</option>
                        <option value="54px 'Brush Script MT', cursive">Script — Brush</option>
                        <option value="48px 'Times New Roman', Times, serif">Times New Roman</option>
                    </select>
                </div>
                <div>
                    <label for="size">Text Size</label>
                    <div style="display: flex; align-items: center; height: 42px;"> <!-- Align with select height roughly -->
                        <input id="size" type="range" min="28" max="84" value="48" />
                    </div>
                </div>
            </div>

            <!-- Appearance Grid -->
            <div class="grid-4" style="margin-top: 1rem;">
                <div>
                    <label for="textColor">Color</label>
                    <input id="textColor" type="color" value="#ffffff" />
                </div>
                <div>
                    <label for="accentColor">Accent</label>
                    <input id="accentColor" type="color" value="#06b6d4" />
                </div>
                <div>
                    <label for="textStyle">Style</label>
                    <select id="textStyle">
                        <option value="" selected>Normal</option>
                        <option value="oblique">Oblique</option>
                        <option value="italic">Italic</option>
                    </select>
                </div>
                <div>
                    <label for="textWeight">Weight</label>
                    <select id="textWeight">
                        <option value="100">100</option>
                        <option value="300">300</option>
                        <option value="500" selected>500</option>
                        <option value="700">700</option>
                        <option value="900">900</option>
                    </select>
                </div>
            </div>

            <!-- Backgrounds -->
            <label>Background Style</label>
            
            <!-- Presets -->
            <div class="bg-options">
                <button class="btn" style="padding: 0.4rem 0.8rem; font-size: 0.8rem;" data-bg="#111827">Dark</button>
                <button class="btn" style="padding: 0.4rem 0.8rem; font-size: 0.8rem;" data-bg="#f8fafc">Light</button>
                <button class="btn" style="padding: 0.4rem 0.8rem; font-size: 0.8rem;" data-bg="135deg,#7c3aed,#06b6d4">Purple</button>
                <button class="btn" style="padding: 0.4rem 0.8rem; font-size: 0.8rem;" data-bg="180deg,#f97316,#f43f5e">Sunset</button>
                <button id="suggestedBg" class="btn" style="padding: 0.4rem 0.8rem; font-size: 0.8rem;">✨ Surprise Me</button>
            </div>

            <!-- Custom Controls -->
            <div class="grid-2" style="margin-bottom: 1rem;">
                <div>
                    <label>Solid Color</label>
                    <input type="color" id="solidBg" />
                </div>
                <div>
                    <label>Gradient Angle</label>
                    <div style="display: flex; align-items: center; height: 40px;">
                        <input id="gradientAngle" type="range" min="0" max="360" value="45" step="1"/>
                    </div>
                </div>
            </div>
            
            <div class="grid-2">
                <div>
                    <label>Gradient Start</label>
                    <input type="color" id="gradientBg1" value="#000000">
                </div>
                <div>
                    <label>Gradient End</label>
                    <input type="color" id="gradientBg2" value="#ffffff">
                </div>
            </div>
            
            <div style="margin-top: 1rem;">
                <button id="uploadBg" class="btn" style="width: 100%;">Upload Background Image</button>
                <input id="bgFile" type="file" accept="image/*" class="hidden" />
            </div>

            <!-- Export Options -->
            <label for="sizeSelect" style="margin-top: 2rem;">Export Format</label>
            <select id="sizeSelect">
                <option value="1080">Instagram post — 1:1</option>
                <option value="1350">Instagram portrait — 4:5</option>
                <option value="1920">Story / Reel — 9:16</option>
            </select>

            <!-- Actions -->
            <div class="actions">
                <button id="renderBtn" class="btn btn-primary">Render Preview</button>
                <button id="downloadBtn" class="btn">Download PNG</button>
                <button id="downloadVideoBtn" class="btn">Video</button>
                <button id="copyCaption" class="btn">Copy Caption</button>
            </div>
        </section>

        <!-- Preview Section -->
        <section id="preview-section" class="preview-wrapper">
            <div class="canvas-container">
                <canvas id="preview" width="540" height="540"></canvas>
            </div>
            <p id="resInfo" style="color: var(--text-muted); font-size: 0.85rem; font-family: monospace;">1080×1080</p>
        </section>
    </div>

    <!-- Main Logic -->
    <script>
        // Existing Quote Writer Logic
        const qoutesApiUrl = "https://api.adviceslip.com/advice";
        const quoteEl = document.getElementById('quote');
        const authorEl = document.getElementById('author');
        const fontEl = document.getElementById('font');
        const sizeEl = document.getElementById('size');
        const textColorEl = document.getElementById('textColor');
        const textStyleEl = document.getElementById('textStyle');
        const textWeightEl = document.getElementById('textWeight');
        const accentEl = document.getElementById('accentColor');
        const randomBtn = document.getElementById('randomBtn');
        const renderBtn = document.getElementById('renderBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const downloadVideoBtn = document.getElementById('downloadVideoBtn');
        const copyCaptionBtn = document.getElementById('copyCaption');
        const preview = document.getElementById('preview');
        const ctx = preview.getContext('2d');
        const options = document.querySelectorAll('[data-bg]');
        const bgFile = document.getElementById('bgFile');
        const solidBg = document.getElementById('solidBg');
        const gradientBg1 = document.getElementById('gradientBg1');
        const gradientBg2 = document.getElementById('gradientBg2');
        const gradientAngle = document.getElementById('gradientAngle');
        const suggestedBg = document.getElementById('suggestedBg');
        const uploadBg = document.getElementById('uploadBg');
        const sizeSelect = document.getElementById('sizeSelect');
        const resInfo = document.getElementById('resInfo');

        let backgroundStyle = '#111827';
        let backgroundImage = null;
        let animationRunning = false;

        function setPreviewResolution(targetBase) {
            const baseW = 1080;
            let height = parseInt(targetBase, 10);
            let width = 1080;
            const scale = .5;
            preview.width = Math.round(width * scale);
            preview.height = Math.round(height * scale);
            resInfo.textContent = `${width}×${height}`;
            renderPreview();
        }

        sizeSelect.addEventListener('change', () => setPreviewResolution(sizeSelect.value));
        // Initial set
        setPreviewResolution(sizeSelect.value);

        function extractColors(value) {
            if (value.includes(',')) {
                const data = value.split(",");
                return [data[1], data[2], data[0]];
            }
            return value;
        }

        function mixColors(color1, color2, weight = 0.5) {
            color1 = color1.replace('#', '');
            color2 = color2.replace('#', '');
            
            const r1 = parseInt(color1.substring(0, 2), 16);
            const g1 = parseInt(color1.substring(2, 4), 16);
            const b1 = parseInt(color1.substring(4, 6), 16);

            const r2 = parseInt(color2.substring(0, 2), 16);
            const g2 = parseInt(color2.substring(2, 4), 16);
            const b2 = parseInt(color2.substring(4, 6), 16);

            const r = Math.round(r1 + (r2 - r1) * weight);
            const g = Math.round(g1 + (g2 - g1) * weight);
            const b = Math.round(b1 + (b2 - b1) * weight);

            const toHex = v => v.toString(16).padStart(2, '0');
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }

        function gradientEndpointsForAngle(angleDeg, w, h) {
            const angle = (angleDeg % 360) * Math.PI / 180;
            const ux = Math.cos(angle);
            const uy = Math.sin(angle);
            const cx = w / 2;
            const cy = h / 2;
            const halfDiagonal = Math.sqrt(w * w + h * h) / 2;
            const x0 = cx - ux * halfDiagonal;
            const y0 = cy - uy * halfDiagonal;
            const x1 = cx + ux * halfDiagonal;
            const y1 = cy + uy * halfDiagonal;
            return { x0, y0, x1, y1 };
        }

        function getGradientFromSentiment(quote) {
            try {
                // Check if sentiment library exists
                if (window.sentiment) {
                    const sentiment = new window.sentiment();
                    const result = sentiment.analyze(quote);
                    const score = result.score;
                    console.log(`Sentiment score: ${score}`);
                    
                    const pickGradient = (choices) => {
                        const gradient = choices[Math.floor(Math.random() * choices.length)];
                        const angle = [30, 45, 60, 90, 120][Math.floor(Math.random() * 5)];
                        return [...gradient, angle];
                    };

                    const gradients = {
                        veryPositive: [["#ff9a9e", "#fad0c4"], ["#fbc2eb", "#a6c1ee"], ["#fddb92", "#d1fdff"], ["#84fab0", "#8fd3f4"]],
                        mildlyPositive: [["#a1c4fd", "#c2e9fb"], ["#89f7fe", "#66a6ff"], ["#a8edea", "#fed6e3"], ["#d4fc79", "#96e6a1"]],
                        neutral: [["#fdfbfb", "#ebedee"], ["#d7d2cc", "#304352"], ["#cfd9df", "#e2ebf0"], ["#bdc3c7", "#2c3e50"]],
                        mildlyNegative: [["#757f9a", "#d7dde8"], ["#636363", "#a2ab58"], ["#b8c6db", "#f5f7fa"], ["#9796f0", "#fbc7d4"]],
                        veryNegative: [["#232526", "#414345"], ["#0f2027", "#203a43"], ["#373b44", "#4286f4"], ["#485563", "#29323c"]]
                    };

                    if (score > 3) return pickGradient(gradients.veryPositive);
                    if (score > 1) return pickGradient(gradients.mildlyPositive);
                    if (score < -3) return pickGradient(gradients.veryNegative);
                    if (score < -1) return pickGradient(gradients.mildlyNegative);
                    return pickGradient(gradients.neutral);
                }
            } catch (e) {
                console.warn("Sentiment library not loaded", e);
            }
            // Fallback gradient if library fails
            return ["#111827", "#374151", 45];
        }

        // Event Listeners
        options.forEach(o => o.addEventListener('click', () => { 
            backgroundStyle = extractColors(o.dataset.bg); 
            backgroundImage = null; 
            renderPreview(); 
        }));

        suggestedBg.addEventListener('click', () => {
            backgroundImage = null;
            backgroundStyle = getGradientFromSentiment(quoteEl.value);
            renderPreview();
        });

        randomBtn.addEventListener('click', async () => {
            try {
                const response = await fetch(qoutesApiUrl);
                const data = await response.json();
                if (data && data.slip) {
                    quoteEl.value = data.slip.advice;
                    authorEl.value = "Unknown"; // API doesn't provide author usually
                    renderPreview();
                }
            } catch (err) {
                console.error("Failed to fetch quote", err);
            }
        });

        uploadBg.addEventListener('click', () => bgFile.click());
        
        bgFile.addEventListener('change', e => {
            const f = e.target.files[0]; if (!f) return;
            const url = URL.createObjectURL(f);
            const img = new Image();
            img.onload = () => { backgroundImage = img; URL.revokeObjectURL(url); renderPreview(); }
            img.src = url;
        });

        solidBg.addEventListener('input', (e) => { // Changed to input for real-time
            backgroundImage = null;
            backgroundStyle = e.target.value;
            renderPreview();
        });

        gradientBg1.addEventListener('input', (e) => {
            backgroundImage = null;
            if (typeof backgroundStyle === 'string') {
                backgroundStyle = [e.target.value, gradientBg2.value];
            } else {
                backgroundStyle[0] = e.target.value;
            }
            renderPreview();
        });

        gradientBg2.addEventListener('input', (e) => {
            backgroundImage = null;
            if (typeof backgroundStyle === 'string') {
                backgroundStyle = [gradientBg1.value, e.target.value];
            } else {
                backgroundStyle[1] = e.target.value;
            }
            renderPreview();
        });

        gradientAngle.addEventListener('input', (e) => {
            backgroundImage = null;
            if (typeof backgroundStyle === 'string') {
                backgroundStyle = [gradientBg1.value, gradientBg2.value, parseInt(e.target.value)];
            } else {
                backgroundStyle[2] = parseInt(e.target.value);
            }
            renderPreview();
        });

        function renderPreview() {
            quoteRenderer(preview, ctx);
        }

        function quoteRenderer(_canvas, _ctx) {
            const w = _canvas.width;
            const h = _canvas.height;
            _ctx.clearRect(0, 0, w, h);

            if (backgroundImage) {
                const scale = Math.max(w / backgroundImage.width, h / backgroundImage.height);
                const scaledWidth = backgroundImage.width * scale;
                const scaledHeight = backgroundImage.height * scale;
                const offsetX = (w - scaledWidth) / 2;
                const offsetY = (h - scaledHeight) / 2;
                _ctx.drawImage(backgroundImage, offsetX, offsetY, scaledWidth, scaledHeight);
            } else {
                if (typeof backgroundStyle !== 'string') {
                    const angle = parseFloat(backgroundStyle[2] || 45);
                    const { x0, y0, x1, y1 } = gradientEndpointsForAngle(angle, w, h);
                    const gradient = _ctx.createLinearGradient(x0, y0, x1, y1);
                    const c1 = backgroundStyle[0] || '#000000';
                    const c2 = backgroundStyle[1] || '#ffffff';
                    gradient.addColorStop(0, c1);
                    gradient.addColorStop(.5, mixColors(c1, c2, .5));
                    gradient.addColorStop(1, c2);
                    _ctx.fillStyle = gradient;
                    _ctx.fillRect(0, 0, w, h);
                } else {
                    _ctx.fillStyle = backgroundStyle;
                    _ctx.fillRect(0, 0, w, h);
                }
            }

            // Overlay
            _ctx.fillStyle = 'rgba(0,0,0,0.28)';
            _ctx.fillRect(0, 0, w, h);

            // Accent Bar
            _ctx.fillStyle = accentEl.value;
            _ctx.beginPath();
            // Fallback for roundRect in older browsers? Mobile Safari supports it now.
            if (_ctx.roundRect) {
                _ctx.roundRect(w * 0.06, h * 0.06, w * 0.88, h * 0.015, w * 0.88);
            } else {
                _ctx.rect(w * 0.06, h * 0.06, w * 0.88, h * 0.015);
            }
            _ctx.fill();

            // Text
            const fontFamily = fontEl.value.split(' ').slice(1).join(' ');
            const fontSize = parseInt(sizeEl.value, 10) * (_canvas.width / 1080);

            _ctx.font = `${textStyleEl.value} ${textWeightEl.value} ${fontSize}px ${fontFamily}`;
            _ctx.fillStyle = textColorEl.value;
            _ctx.textAlign = 'center';
            _ctx.shadowColor = 'rgba(0,0,0,0.45)';
            _ctx.shadowBlur = 6;

            const quote = quoteEl.value.trim();
            const author = authorEl.value.trim();
            const lineHeight = fontSize * 1.1;
            const padding = w * 0.12;
            const maxWidth = w - padding * 2;
            const words = quote.split(' ');
            let lines = [''];

            for (const word of words) {
                const testLine = lines.at(-1) + (lines.at(-1) ? ' ' : '') + word;
                if (_ctx.measureText(testLine).width > maxWidth) {
                    lines.push(word);
                } else {
                    lines[lines.length - 1] = testLine;
                }
            }

            const totalHeight = (lines.length + (author ? 1.5 : 0)) * lineHeight;
            let y = ((h - totalHeight) / 2) + (lineHeight); 

            // Adjust y slightly based on slider to allow manual vertical shift? 
            // Original code had a shift logic: ((h - totalHeight) / 1.8) + ((sizeEl.value / 84) * 40);
            // Let's stick to centering for now to be safe.
             y = ((h - totalHeight) / 1.8) + (fontSize * 0.5);

            lines.forEach(line => {
                _ctx.fillText(line, w / 2, y);
                y += lineHeight;
            });

            if (author) {
                _ctx.font = `${fontSize * 0.6}px ${fontFamily}`;
                _ctx.fillText(author, w / 2, h - (lineHeight * 1.5));
            }
        }

        renderBtn.addEventListener('click', renderPreview);
        [quoteEl, authorEl, fontEl, sizeEl, textColorEl, accentEl, textStyleEl, textWeightEl].forEach(el => el.addEventListener('input', renderPreview));
        
        // Initial render
        renderPreview();

        downloadBtn.addEventListener('click', () => {
            const c = document.createElement('canvas'); 
            c.width = 1080; 
            c.height = parseInt(sizeSelect.value, 10);
            const g = c.getContext('2d');
            
            // Standardizing export to 1x scale for consistent file size or usage
            // But preserving HighDPI if user wants? usually for export we want exact pixels of 1080w.
            
            quoteRenderer(c, g);

            c.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const aTag = document.createElement('a');
                aTag.href = url;
                aTag.download = 'quote-' + Date.now() + '.png';
                aTag.click();
                URL.revokeObjectURL(url);
            });
        });

        downloadVideoBtn.addEventListener('click', () => {
            if (animationRunning || typeof backgroundStyle === 'string') return;
            animationRunning = true;

            const c = document.createElement('canvas'); 
            c.width = 1080; 
            c.height = parseInt(sizeSelect.value, 10);
            const g = c.getContext('2d');

            const stream = c.captureStream(30);
            const chunks = [];
            const recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 5_000_000 });
            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'quote-video.webm';
                a.click();
                URL.revokeObjectURL(url);
                animationRunning = false;
            };
            recorder.start();

            const duration = 6; 
            const totalFrames = duration * 30;
            let frame = 0;

            function animate() {
                const progress = frame / totalFrames;
                // Rotate hue or angle? Original rotated angle.
                // make sure backgroundStyle is array
                if (Array.isArray(backgroundStyle)) {
                     backgroundStyle[2] = (progress * 360) % 360;
                }
                
                quoteRenderer(c, g);
                frame++;
                if (frame < totalFrames) requestAnimationFrame(animate);
                else recorder.stop();
            }
            animate();
        });

        copyCaptionBtn.addEventListener('click', () => {
            const caption = `${quoteEl.value.trim()}\n${authorEl.value.trim()}\n\n#quote #motivation #lifequotes #inspiration #mindset #positivity`;
            navigator.clipboard.writeText(caption).then(() => {
                const originalText = copyCaptionBtn.textContent;
                copyCaptionBtn.textContent = 'Copied!';
                setTimeout(() => copyCaptionBtn.textContent = originalText, 1500);
            });
        });

        // Theme Toggle Logic
        const themeToggleBtn = document.getElementById('theme-toggle');
        const sunIcon = document.getElementById('sun-icon');
        const moonIcon = document.getElementById('moon-icon');

        function updateThemeIcons(theme) {
            if (theme === 'dark') {
                sunIcon.classList.add('hidden');
                moonIcon.classList.remove('hidden');
            } else {
                moonIcon.classList.add('hidden');
                sunIcon.classList.remove('hidden');
            }
        }

        // Init theme
        const savedTheme = localStorage.getItem('theme') || 'light';
        document.documentElement.setAttribute('data-theme', savedTheme);
        updateThemeIcons(savedTheme);

        themeToggleBtn.addEventListener('click', () => {
             const current = document.documentElement.getAttribute('data-theme');
             const next = current === 'dark' ? 'light' : 'dark';
             document.documentElement.setAttribute('data-theme', next);
             localStorage.setItem('theme', next);
             updateThemeIcons(next);
        });

    </script>
</body>
</html>